### Deadlock

#### 实验死锁截图

![](http://p1.bpimg.com/567571/6d8d1b89446a45d8.png)

可以看到这里的死锁停在了第13次运行。

#### 实验过程

关于关键字 synchronized

* 当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。
* 当一个线程访问object的一个synchronized同步代码块或同步方法时，其他线程对object中所有其它synchronized同步代码块或同步方法的访问将被阻塞。

![](http://p1.bpimg.com/567571/d73675af912deabf.png)

可以看到我们首先设置的是在A类中定义了b的一个函数，在B类中定义了a的一个函数，均叫last

![](http://p1.bpimg.com/567571/0bb54851b524e9bd.png)

当t.start()之后，就开始跑run()里面的代码，这时候同时也会在一个延迟后开始执行a里面的函数，这两者可能会同时发生，这样就会发生死锁了。

我们要做的事情很简单，不断执行，直到它产生死锁为止：

```java
#!/bin/bash

for((c=1;c<=10000;c++))
do
	echo "$c times"
	java Deadlock
done
```

上面就是主要的实验过程了。

#### Deadlock发生的四个必要条件

- 互斥条件：一个资源每次只能被一个进程使用
- 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
- 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺
- 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系